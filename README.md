# sd-rogue-like

1. Общие сведения о системе
```
Название: Roguelike Game
Тип: 2D пошаговая одиночная игра с процедурной генерацией.
Платформа: ПК (Windows/Linux/macOS)
Технологии: C#, Unity
Описание: Игрок управляет героем, исследует подземелья, сражается с монстрами, собирает полезные предметы и стремится выжить.
```

2. Architectural Drivers

```
Функциональные драйверы:

    Пошаговое перемещение и действия

    Генерация случайных уровней

    Бои с врагами

    Инвентарь, предметы, прокачка
    
    Меню

    Игровой интерфейс
```
```
Нефункциональные драйверы:

    Расширяемость (новые враги, предметы)

    Кроссплатформенность

    Читабельность и модульность кода

    Высокая отзывчивость UI (интерфейс не должен тормозить)
```
3. 
| Роль          | Возможности                                                       |
|---------------|--------------------------------------------------------------------|
| Игрок         | Управляет героем, перемещается, сражается, использует предметы    |
| Система       | Генерирует уровни, управляет врагами и логикой боя                |
| Противник  | Реагирует на действия игрока, принимает решения, атакует                |

```
Основные Use Cases:

    Игрок перемещается по карте

    Игрок атакует врага

    Игрок подбирает предмет

    Игра генерирует новый уровень

    Игра завершает сессию при смерти игрока
```
4. Описание типичного пользователя

    Игрок, любит сложность, знаком с RPG играми

    Цель: Найти максимально эффективную стратегию выживания, исследовать все уровни, собрать редкие артефакты.

5. Композиция (диаграмма компонентов)

Компоненты:

    GameEngine — основной управляющий модуль

    MapGenerator — генерация уровней

    EntitySystem — игрок, монстры, NPC

    TurnManager — контроль пошаговости

    UIManager — отображение интерфейса

    InventorySystem — предметы и экипировка

    SaveSystem — сохранение и загрузка игры

Диаграмму могу нарисовать по запросу (текст или картинка).
6. Логическая структура (диаграмма классов)

Классы:

```
Entity (base)
 ├─ Player
 ├─ Monster
 ├─ NPC


Item (base)
 ├─ Weapon
 ├─ Armor
 ├─ Consumable 

Map
 ├─ Cell[]
 ├─ has Entity[]
 ├─ has Item[]

Game
 ├─ Map
 ├─ Player
 ├─ Enemy[]
 ├─ Inventory
 ├─ GameState
```
Взаимосвязи:

    Player и Monster наследуют Entity

    Entity может иметь Inventory

    Game управляет текущей Map и списками всех активных объектов

7. Взаимодействия и состояния

Диаграмма состояний (ЛИЛЯ ПЕРЕДЕЛАЙ ТУТ В АВТОМАТ):
```
Player → UIController: нажимает кнопку "атаковать"
UIController → GameEngine: sendCommand("ATTACK", target)
GameEngine → TurnManager: beginPlayerTurn()

TurnManager → CombatSystem: resolveAttack(player, target)
CombatSystem → Monster: takeDamage(amount)

Monster → Monster: updateHP(-amount)
Monster → GameEngine: if (hp <= 0) then markDead()

GameEngine → MapManager: removeEntity(monster)
GameEngine → LootSystem: dropLoot(monster)
GameEngine → TurnManager: endPlayerTurn()

```
8. Описание данных
Entity:
```
{
  "name": "Orc",
  "hp": 20,
  "attack": 4,
  "defense": 2,
  "inventory": [ ... ]
}
```
Map Cell:
```
{
  "type": "floor",
  "entity": "Orc",
  "item": "Sword"
}
```
Item:
```
{
  "id": "healing_potion",
  "type": "consumable",
  "effect": "+10 HP"
}
```
9. Паттерны проектирования
```
    Composite — для сущностей (Entity + компоненты)

    Factory — создание врагов, предметов

    Observer — подписка UI на изменения (HP, инвентарь)

    State — состояния игрока/врагов

    Strategy — поведение врагов (разные типы поведения)

    Singleton — TurnManager, GameEngine, UI manager, SaveSystem
```

10. План приемки

| Этап | Критерий                                     | Проверка                          |
|------|----------------------------------------------|-----------------------------------|
| 1    | Игра запускается и отображает меню           | Ручная проверка                   |
| 2    | Генерация карты работает и уникальна         | Автотест или визуальная проверка |
| 3    | Игрок может двигаться и взаимодействовать    | Ручная проверка                  |
| 4    | Враги реагируют корректно                    | Юнит-тест + поведение             |
| 5    | Предметы подбираются и применяются           | Ручной тест                       |
| 6    | Победа и проигрыш корректно фиксируются      | Игровой сценарий                  |
| 7    | Нет крашей, FPS стабильный                   | Тестирование производительности   |

